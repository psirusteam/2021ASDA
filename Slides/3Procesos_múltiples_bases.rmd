---
title: "Análisis de encuestas de hogares con R"
subtitle: "Módulo 3: Procesamiento de múltiples encuestas de hogares en R"
author: |
  | Andrés Gutiérrez, Ph.D.
  | Stalyn Guerrero, M.Sc. 
date: "CEPAL - Unidad de Estadísticas Sociales"
output:
  beamer_presentation:
    colortheme: dove
    fonttheme: default
    incremental: yes
    theme: Berkeley
    toc: yes
    slide_level: 2
    #highlight: pygments
  ioslides_presentation:
    incremental: yes
    widescreen: yes
    toc: yes
  slidy_presentation:
    incremental: yes
Email: andres.gutierrez@cepal.org
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = FALSE, warning = FALSE, message = FALSE, error = FALSE)
options(digits = 4)
library(magrittr)
library(survey)
library(srvyr)
library(convey)
library(TeachingSampling)
library(printr)
library(furrr)
library(purrr)
library(tidyr)
select <- dplyr::select
```

## Lecturas de múltiples archivos

En algunas ocasiones es necesario procesar más de un archivo para obtener algunos resultados de interés, y contamos con la fortuna que los activos poseen la misma estructura (extensión, nombre de columnas). Por ejemplo, cuando tenemos el censo del país dividido por región o departamento otro caso puede ser las encuestas tomadas en diferentes periodos. En estos casos podemos realizar un procesamiento por medio de loop o alternativas como el proceso por mapeo de listas o procesos en paralelo.

## Identificando las rutas de los archivos

Para realizar la lectura de múltiples bases debemos conocer las rutas donde estas estas guardadas, lo que podemos simplificar con la función `file.list` del paquete `base`, que nos permite tener un listado completo de los archivos.

```{r, tab_mult0, eval=FALSE}
(data_path <- list.files("Z:/BC/",
  full.names = TRUE,
  pattern = "2020"
)[1:5])
```

## Identificando las rutas de los archivos

\scriptsize

```{r, tab_mult0, eval=TRUE, echo=FALSE}
```

### Identificando los países. 

Para poder identificar que archivo estamos procesando se crea una columna adicional con el nombre del país.

```{r}
data_path <- tibble(path = data_path) %>%
  mutate(pais = gsub("Z:\\/BC\\/(.*)_.*", "\\1",
    x = path
  ))
```

## Identificando los países. 

```{r, echo=FALSE}
data_path
```


## Funicón para operar listas

### Función `lapply` y `sapply` 
Estas funciones están disponible en el paquete `base` de `R`. Sintaxis,
```{r, eval=FALSE}
## Cinco muestras aleatorias con n = 10
lapply(rep(10, 5), rnorm )
sapply(rep(10, 5), rnorm , simplify = TRUE)
```


### Familia de funciones `map`
La familia `map` amplio las posibilidades para trabajar con los elementos de las listas.
`map` hace parte del paquete `purrr`, el cual cuenta con funciones adicionales como: 

-   `map` permite ingresar un listas que será mapeada elemento a elemento, por ejemplo.
    ```{r, eval = FALSE}
    map(.x = rep(10,5), rnorm)
    ```


## Familia de funciones `map`
-   `map2` permite ingresar dos listas que interactúen entre sí para obtener un resultado, por ejemplo.
    ```{r, eval = FALSE}
    map2(.x = rep(10,5),
         .y = 1:5,
         ~rnorm(n=.x, mean = .y))
    ```

-   `pmap` : esta permiten operar con listas de parámetro. Por ejemplo:

    ```{r, eval = FALSE}
    pmap(list(
      n = rep(10, 5),
      mean = 1:5,
      sd = 1 / 1:5
    ),
    rnorm)
    ```


## Funicón para operar listas

### Familia de funciones `future_map`
La familia `future_map` amplio las posibilidades de realizar procesamientos en parlero, como podemos notar  por el nombre, tiene la misma lógica de uso que la familia `map`.
Estas funciones las podemos encontrar en el paquete `furrr`. 

\pause
La familia de funciones `map` y `future_map` tiene una extensión más, la cual permiten organizar los  resultados teniendo en cuenta el tipo de resultados que se este reportando,por ejemplo:

-  `_dbl` unifica salidas tipo numérica en un vector. 
-  `_df`  unifica `data.frame`, equivale hacer `rbind`.



## Lectura de encuestas con `map`

Para la lectura de los archivos, se procede de la siguiente forma.
\scriptsize
```{r, eval=FALSE}
require(purrr)
require(haven)
data_path %<>%
  mutate(encuesta = path %>% map(~ read_dta(.x) %>%
    transmute(
      upm = `_upm`,
      estrato = `_estrato`,
      sexo, areageo2, lp, li, ingcorte,
      fep = `_fep`
    )))
```

\normalsize

Las variables seleccionadas son sexo, área geográfica (areageo2), Linea de pobreza (lp), Linea de indigencia (li), Ingreso por persona (ingcorte) y factor de expansión por persona (fep)

## Lectura de encuestas (resultado)

![](Imagenes/Otros/Lectura%20multiple%20base1.PNG)

El resultado es objeto tipo `tibble` el cual permite observar de forma compacta el contenido de una lista e indica el tipo y tamaño de cada objeto en la contenido en la lista.


## Lectura de encuestas `future_map`


```{r, eval=TRUE}
require(furrr)
require(haven)
plan(multisession, workers = 2)
data_path %<>%
  mutate(encuesta = path %>%
    future_map(~ read_dta(.x) %>%
      transmute(
        upm = `_upm`,
        estrato = `_estrato`,
        sexo, areageo2, lp, li, ingcorte,
        fep = `_fep`
      )))
```


## Definir el diseño

Después de tener las bases disponibles en `R` en momento de definir un diseño muestral para cada encuesta, para nuestro ejemplo se define el siguiente: 

```{r}
options(survey.lonely.psu = "adjust")
plan(multisession, workers = 2)
data_path %<>% mutate(
  diseno = encuesta %>%
    future_map(~ as_survey_design(
      .data = .x,
      ids = upm,
      strata = estrato,
      weights = fep,
      nest = T
    ))
)
```

## Definir el diseño (resultado)

![](Imagenes/Otros/Lectura%20multiple%20base2.PNG)

# Variables continuas

## Estimación de promedios en multiples encuestas

```{r, tab_mult010, eval=FALSE}
library(tidyr)
data_path %>% mutate(ingreso_medios = diseno %>%
             map(~.x %>% 
                   summarise(
          ingreso = survey_mean(ingcorte/lp)))) %>% 
  select(pais,ingreso_medios) %>%
  unnest(ingreso_medios)
```

## Estimación de promedios en multiples encuestas (Resultado)

```{r, tab_mult010, eval=TRUE, echo=FALSE}
```

## Estimación de promedios por sexo en multiples encuestas

```{r, tab_mult02, eval=FALSE}
data_path %>% mutate(
  ingreso_medios = diseno %>%
           map( ~ .x %>% group_by(sexo) %>%
    summarise(ingreso = survey_mean(ingcorte / lp)))) %>%
  select(pais, ingreso_medios) %>%
  unnest(ingreso_medios) %>%
  head(14)
```

## Estimación de promedios por sexo en multiples encuestas (Resultado)

```{r, tab_mult02, eval=TRUE, echo=FALSE}
```

## Estimación de promedios por área en multiples encuestas

```{r, tab_mult03, eval=FALSE}
data_path %>% mutate(ingreso_medios = diseno %>%
             map(~.x %>% group_by(areageo2) %>% 
            summarise(
             ingreso = survey_mean(ingcorte/lp)))) %>% 
  select(pais,ingreso_medios) %>%
  unnest(ingreso_medios) %>% 
  head(14)
```

## Estimación de promedios por área en multiples encuestas (Resultado)

```{r, tab_mult03, eval=TRUE, echo=FALSE}
```

## Pruebas de diferencia de medias por grupo en múltiples encuestas 

Diferencia de ingresos promedio por sexo.
```{r,tab_mult04, eval=FALSE}
data_path[-1,] %>% mutate(pvalor = map_dbl(diseno,
  ~svyttest(formula = ingcorte/lp~sexo, 
            .x, na = TRUE)$p.value  
) ) %>% select(pais, pvalor)

```
### Nota: ARG se quita porque las upm y los estratos no estan debidamente identificadados, tienen valores contrantes.

## Pruebas de diferencia de medias por grupo en múltiples encuestas (Resultado) 

```{r,tab_mult04, eval=TRUE, echo=FALSE}
```

## Estimación del índice de GINI en múltiples encuestas 

```{r,tab_mult05, eval=FALSE}
library(convey)
data_path %>% mutate(
  diseno_gini = map(diseno,convey_prep),
  gini = map(diseno_gini, 
             ~svygini( ~ingcorte, design = .x) %>% 
               data.frame()
  )) %>%
  select(pais,gini) %>% unnest(gini)


```

## Estimación del índice de GINI en múltiples encuestas (Resultado) 

```{r,tab_mult05, eval=TRUE, echo=FALSE}
```

## Estimación de la curva de lorenz en múltiples encuestas 

```{r, tab_mult06, eval=FALSE, echo=TRUE}
par(mfrow = c(2,2))
temp <- data_path[1:3,] %>% mutate(
  diseno_gini = map(diseno,convey_prep),
  lorenz = map2(diseno_gini,pais,
               function(diseno_i,pais_i){
               svylorenz( ~ingcorte, diseno_i,
                           seq(0,1,.05), 
                           alpha = .01, plot = TRUE ,
                           add = FALSE)
                title(pais_i) })
  ) 

```

## Estimación de la curva de lorenz en múltiples encuestas (Resultado) 

```{r, tab_mult06, eval=TRUE, echo=FALSE}
```

## Procesando múltimples variables en la encuesta. 

En estas ocasión es de interés procesar obtener resultados para múltiples preguntas que tienen características similares, para este ejemplo tomaremos las variables, `sys_pe` , `gan_pe` ,  `yemp_pe` , `yjub_pe`, `yotr_pe` y `yto_pe`. Para esto procedemos así: 

```{r, eval=TRUE}
name_var <- c("sys_pe" , "gan_pe" , "yemp_pe" ,
              "yjub_pe", "yotr_pe", "yto_pe")

```

## Leer encuesta y definir diseño muestral 

```{r, eval=TRUE}
# Leer encuesta
encuesta_BOL2020 <- data_path$path[2] %>%
  read_dta(.) %>%
      mutate(
        upm = `_upm`,
        estrato = `_estrato`,
        fep = `_fep`)
# definir diseno 
diseno = as_survey_design(
      .data = encuesta_BOL2020,
      ids = upm,
      strata = estrato,
      weights = fep, nest = T)

```

## Estimando los resultados. 

```{r, eval=TRUE}
resul_mult <- diseno %>%
  filter(edad >= 15, sexo == 2) %>% 
  mutate_at(.vars = all_of(name_var), 
                      ~ ifelse(. > 0, 1, 0)) %>% 
  summarise_at(.vars =  all_of(name_var),
   ~survey_mean(.))
```


```{r, eval=TRUE, echo=FALSE}
resul_mult  %>% gather(key = "variable") %>%
  mutate(
    type = ifelse(grepl(pattern = "_se$", x = variable),
                  "se", "estimado"),
    variable = gsub(
      pattern = "_se$",
      x = variable,
      replacement = ""
    )
  ) %>%
  spread(key = "type", value = "value")

```

## Estimando los resultados, condicionada. 
En esta rutina como obtener estimaciones cuando tenemos que hacer filtro para cada variable

```{r, eval=TRUE}
resul_mult_cond <- map_dfc(
  name_var,
  ~diseno %>%
  filter(edad >= 15, sexo == 2) %>%
  filter_at(all_of(.x), ~ . > 0) %>% 
    summarise_at(all_of(.x), ~survey_mean(.))
)
```


```{r, eval=TRUE, echo=FALSE}
resul_mult_cond  %>% gather(key = "variable") %>%
  mutate(
    type = ifelse(grepl(pattern = "_se$", x = variable),
                  "se", "estimado"),
    variable = gsub(
      pattern = "_se$",
      x = variable,
      replacement = ""
    )
  ) %>%
  spread(key = "type", value = "value")

```


## Estimando los resultados por grupo. 

```{r, eval=TRUE}
resul_mult_grupo <- diseno %>%
  filter(edad >= 15, sexo == 2) %>% 
  mutate_at(.vars = all_of(name_var), 
                      ~ ifelse(. > 0, 1, 0)) %>% 
  group_by(areageo2) %>% 
  summarise_at(.vars =  vars(name_var),
   ~survey_mean(.))
```

## Estimando los resultados por grupo (Resultado)

```{r, eval=TRUE, echo=FALSE}
resul_mult_grupo  %>%
  gather(key = "variable",value = "value", -areageo2) %>%
  mutate(
    type = ifelse(grepl(pattern = "_se$", x = variable),
                  "se", "estimado"),
    variable = gsub(
      pattern = "_se$",
      x = variable,
      replacement = ""
    )
  ) %>%
  spread(key = "type", value = "value") %>% 
  data.frame()

```

## Estimando de resultados en múltiples variables en múltiples archivos

```{r}
data_path %<>%
  mutate(
    encuesta = path %>% map(
    # Lectura de archivo 
    ~ read_dta(.x) %>% 
      mutate(upm = `_upm`,
             estrato = `_estrato`, fep = `_fep`)),
    # Definicion del diseño
    diseno = encuesta %>% map(
      ~ as_survey_design(
        .data = .x,
        ids = upm,
        strata = estrato,
        weights = fep,    nest = T
      )
    )
  )
```

## Procesando los multiples archivos en múltiples variables. 

```{r}
multi_archivo <- data_path %>% transmute(pais,
  promedio = diseno %>%
  map(~.x %>% filter(edad >= 15, sexo == 2) %>% 
  mutate_at(.vars = all_of(name_var), 
                      ~ ifelse(. > 0, 1, 0)) %>% 
  summarise_at(.vars =  all_of(name_var),
   ~survey_mean(.)))) %>%
  unnest(cols = "promedio")

```

## Procesando los múltiples archivos en múltiples variables (Resultado 1). 

```{r,echo=FALSE}
multi_archivo %<>%
  gather(key = "variable",value = "value", -pais) %>%
  mutate(
    type = ifelse(grepl(pattern = "_se$", x = variable),
                  "se", "estimado"),
    variable = gsub(
      pattern = "_se$",
      x = variable,
      replacement = ""
    )
  ) %>%
  spread(key = "type", value = "value") %>% 
  data.frame()
multi_archivo[(1:9),]
```

## Procesando los múltiples archivos en múltiples variables (Resultado 2). 

```{r,echo=FALSE}
multi_archivo[-(1:9),]
```



## Alternativa para el procesamiento de múltiples archivos.

En ocasiones solo se desea obtener un resultado rápido para realizar un reporte o una comparación rápida de información, en estas ocasiones no es necesario guardar en la memoria de `R` toda la encuesta, por esta razón se ilustra una alternativa de procesamiento de múltiples archivos.  

- **Paso 1** Leer archivo y organizar encuestas. 
- **Paso 2** Definir diseño muestral. 
- **Paso 3** Procesar información.
- **Paso 4** Organizar y presentar resultados. 

## Creando función para el procesamiento de múltiples archivos.
\scriptsize
```{r}
options(survey.lonely.psu="adjust")
Promedio_aux <- function(input_file){
  pais = gsub("Z:\\/BC\\/(.*)_.*", "\\1",
    x = input_file)
  ## Paso 1 
  encuesta <- read_dta(input_file) %>% 
    transmute(upm = `_upm`,
              estrato =`_estrato`,
              sexo, areageo2,lp,li,ingcorte,
              fep =`_fep`)
  ## Paso 2 
  diseno <- as_survey_design(.data = encuesta,
                             ids = upm,
                             strata = estrato, 
                             weights = fep,
                             nest = T
  )
  ## Paso 3 
  diseno %>% summarise(
    ingreso = survey_mean(ingcorte/lp)) %>% 
    data.frame() %>% mutate(pais = pais)
}

```

## Procesando encuestas múltiples
Para el *Paso 4* realizamos la siguiente sintaxis.

```{r,tab0_mult7, echo=TRUE, eval=FALSE}
list.files("Z:/BC/",full.names = TRUE, 
                        pattern = "2020")[1:3] %>% 
  map_df(~Promedio_aux(.x))
```

```{r,tab0_mult7, echo=FALSE, eval=TRUE}
```


## Obteniendo alguno resultados simples

Si el interés es obtener una medición simple de las bases, como lo puedes ser un promedio ponderado, es posible que utilicemos la función `weighted.mean` con la siguiente instrucción

\scriptsize
```{r,tab1_mean, eval=FALSE}
plan(multisession, workers = 2)
data_path %>%
  transmute(pais,
            promedio = encuesta %>%
              future_map_dbl(
                ~ .x %>% summarise(
                  media = weighted.mean(ingcorte/lp, fep)) %>% 
                  as.numeric()))

```

## Obteniendo alguno resultados simples
```{r,tab1_mean,eval=TRUE,echo=FALSE}
```



## Obteniendo alguno resultados simples por grupo

\scriptsize
```{r,tab2_mean, eval=FALSE}
plan(multisession, workers = 2)
data_path %>%
  transmute(pais,
            promedio = encuesta %>%
              future_map(
                ~ .x %>% group_by(sexo) %>% 
                  summarise(
                  media = weighted.mean(ingcorte/lp, fep)))) %>% 
  unnest(promedio) %>% 
  spread(key = "sexo", value = "media")

```

## Obteniendo alguno resultados simples por grupo
```{r,tab2_mean,eval=TRUE,echo=FALSE}
```

## Obteniendo estimaciones complejas

Si el interés es obtener un resultado un poco más complejo, por ejemplo una razón de dos totales, es necesario que definamos nuestra propia función 

```{r}
weighted.ratio <- function(num, den, w){
  num = sum(num*w)
  den = sum(den*w)
  data.frame(num,den,ratio = num/den)
}

```

\scriptsize
```{r,tab3_ratio, eval=FALSE}
data_path %>%
  transmute(pais,
    ratio = encuesta %>%
      map(~ .x  %>% 
             summarise(
             ratio = weighted.ratio(sexo == 1, sexo == 2, fep)))) %>% 
  unnest(ratio) %>% unnest(ratio)

```

## Obteniendo estimaciones complejas

```{r,tab3_ratio,eval=TRUE,echo=FALSE}
```

## Obteniendo estimaciones complejas con restricciones. 
Al definir nuestra función es posible que necesitemos hacer algunas restricciones para el calculo. Por ejemplo, ingresos mayores a cero. 

```{r}
weighted_mean_cond <- function(x, w){
  xi <- x[x>0]
  wi <- w[x>0]
  sum(xi*wi)/sum(wi)
}

```

\scriptsize
```{r,tab4_ratio, eval=FALSE}
data_path %>%
  transmute(pais,
    promedio = encuesta %>%
     map(~ .x  %>%group_by(sexo) %>% 
           summarise(
            media = weighted.mean(ingcorte/lp, fep),
            media_cond = weighted_mean_cond(ingcorte/lp, fep)))) %>% 
  unnest(promedio)

```

## Obteniendo estimaciones complejas con restricciones. 
\tiny
```{r, tab4_ratio, eval=TRUE, echo=FALSE}
```

# Variables categóricas

## Lectura de múltiples bases

Para realizar la lectura de múltiples bases debemos conocer las rutas donde estas estas guardadas para ello empleamos la función `file.list` del paquete base, que nos permite tener un listado completo de los archivos.


```{r, tab_mult01, eval=FALSE}
library(tibble)
(data_path <- list.files("Z:/BC/", full.names = TRUE,
                        pattern = "2020") %>%  tibble(path = .) %>%
  mutate(pais = gsub("Z:\\/BC\\/(.*)_.*", "\\1",
                     x = path)))
  
```

*Note* que utiliza la función `gsub` para separar el nombre del país de la ruta.


## Lectura de múltiples bases

```{r, tab_mult01, eval=TRUE, echo=FALSE}
```


## Lectura de encuestas

Para la lectura de los archivos, se procede de la siguiente forma.

```{r, eval=TRUE}
require(purrr)
require(haven)
data_path %<>% 
  mutate(encuesta = path %>% map(~read_dta(.x) %>% 
           transmute(upm = `_upm`,
           estrato =`_estrato`,
           sexo, areageo2,lp,li,ingcorte,
           fep =`_fep`)))
```


## Definir el diseño

Ahora se debe definir un diseño para cada encuesta, para nuestro ejemplo se define el diseño muestral.

```{r}
options(survey.lonely.psu="adjust")
data_path %<>% mutate(
  diseno = encuesta %>%
           map(~as_survey_design(.data = .x,
               ids = upm,
               strata = estrato, 
               weights = fep,
               nest = T
               )))
```

## Estimación de las personas debajo de la linea de pobreza en multiples encuestas

```{r, tab_mult1, eval=FALSE}
library(tidyr)
data_path %>% mutate(Pobreza = diseno %>%
             map(~.x %>% 
                   summarise(
                     Prop = survey_mean(
                       ingcorte<lp, 
                       vartype = c("se","cv") )))) %>% 
  select(pais,Pobreza) %>%
  unnest(Pobreza) %>% 
  head(14)
```

## Estimación de las personas con ingresos de bajo de la linea de pobreza en multiples encuestas (Resultado)

```{r, tab_mult1, eval=TRUE, echo=FALSE}
```

## Estimación de las personas con ingresos de bajo de la linea de pobreza en multiples encuestas

```{r, tab_mult2, eval=FALSE}
data_path %>% mutate(Pobreza = diseno %>%
             map(~.x %>% group_by(sexo) %>% 
                   cascade(
                     Prop = survey_mean(
                       ingcorte<lp, 
                       vartype = c("se","cv")),
                     .fill = 3 ))) %>% 
  select(pais,Pobreza) %>%
  unnest(Pobreza) %>% 
  head(14)
```
_.fill = 3 _ permite poner un nombre al resultado grobal

## Estimación de las personas debajo de la linea de pobreza en multiples encuestas (Resultado)

```{r, tab_mult2, eval=TRUE, echo=FALSE}
```

## Estimación de las personas con ingresos de bajo de la linea de pobreza en multiples encuestas

```{r, tab_mult3, eval=FALSE}
data_path %>% mutate(Pobreza = diseno %>%
             map(~.x %>% group_by(areageo2) %>% 
                   cascade(
                     Prop = survey_mean(
                       ingcorte<lp, 
                       vartype = c("se","cv")),
                     .fill = 3 ))) %>% 
  select(pais,Pobreza) %>%
  unnest(Pobreza) %>% 
  head(14)
```


## Estimación de las personas debajo de la linea de pobreza en multiples encuestas (Resultado)

```{r, tab_mult3, eval=TRUE, echo=FALSE}
```

## Prueba de independencia en múltiples encuestas
Se retira Argentina del ejemplo por no tener información en el área rural. 

```{r, tab_mult4, eval=FALSE}
data_path[-1,] %>% 
  mutate(test_chisq = map_dbl(diseno,
  ~svychisq(~areageo2+sexo,
            design = .x,
            statistic="F")$p.value
)) %>% select(pais, test_chisq)

```

## Estimación de las personas con ingresos de bajo de la linea de pobreza en multiples encuestas (Resultado)

```{r, tab_mult4, eval=TRUE, echo=FALSE}
```



## Alternativa para el procesamiento de múltiples archivos.

En ocasiones solo se desea obtener un resultado rápido para realizar un reporte o una comparación rápida de información, en estas ocasiones no es necesario guardar en la memoria de `R` toda la encuesta, por esta razón se ilustra una alternativa de procesamiento de múltiples archivos.  

- **Paso 1** Leer archivo y organizar encuestas. 
- **Paso 2** Definir diseño muestral. 
- **Paso 3** Procesar información.
- **Paso 4** Organizar y presentar resultados. 

## Creando función para el procesamiento de múltiples archivos.
\tiny

```{r}
options(survey.lonely.psu="adjust")
Promedio_aux <- function(input_file){
  ## Paso 1 
  encuesta <- read_dta(input_file) %>% 
    transmute(upm = `_upm`,
              estrato =`_estrato`,
              sexo, areageo2,lp,li,ingcorte,
              fep =`_fep`)
  ## Paso 2 
  diseno <- as_survey_design(.data = encuesta,
                             ids = upm,
                             strata = estrato, 
                             weights = fep,
                             nest = T
  )%>% mutate(pobreza = ifelse(ingcorte<lp,1,0))
  ## Paso 3 
  svyby(~as.factor(pobreza), ~sexo,
        diseno, svymean) %>% 
    tibble()
}

```

## Procesando encuestas múltiples
Para el *Paso 4* realizamos la siguiente sintaxis.

```{r,tab_mult7, echo=TRUE, eval=FALSE}
list.files("Z:/BC/",full.names = TRUE, 
                        pattern = "2020")[1:3] %>% 
  map_df(~Promedio_aux(.x)) 

```
Los resultados se muestran en el orden de lectura de los archivos
\tiny
```{r,tab_mult7, echo=FALSE, eval=TRUE}
```

## Ejemplo Bolivia 2015 a 2020

### Lectura de las bases de datos.
```{r, eval=TRUE}
# lista con la ruta de los archivos
input_file <- list.files("Z:/BC/",full.names = TRUE,
                   pattern = "(BOL_201[5-9]|BOL_2020)")
```
\tiny
```{r, echo=FALSE}
input_file
```

```{r, eval=TRUE}
# identificando el año
anio <-gsub(x = input_file, pattern = ".*(\\d{4}).*","\\1")
# definir las variables de interes.
name_var <- c("sys_pe" , "gan_pe" , 
              "yemp_pe" , "yjub_pe",
              "yotr_pe", "yto_pe")

```

## Bolivia 2015 a 2020
\tiny
```{r, eval=TRUE}
library(furrr)
# definir los nucleos para el procesamiento 
plan(multisession, workers = 3)
# Lectura, filtro de la base y selección de variables por archivo.

encuesta <- setNames(input_file,anio) %>% ## años de los archivos
  future_map(~read_dta(.x) %>%            ## lectura de archivos 
  mutate(fep =`_fep`,                     ## renombrando variable
         upm = `_upm`,
         estrato =`_estrato`,) %>%                 
  filter(edad >= 15, sexo == 2) %>%         ## filtro de edad y sexo
  select(upm, estrato,fep,all_of(name_var)) ## seleccion de variable
  )
```


## Bolivia 2015 a 2020
Definir el diseño 
```{r,echo=TRUE}
diseno = encuesta %>% future_map(
      ~ as_survey_design(
        .data = .x,
        ids = upm,
        strata = estrato,
        weights = fep,    nest = T
      )
    )
```

## Bolivia 2015 a 2020
\tiny
```{r}
diseno %>%
  future_map_dfr(~.x %>%
  mutate_at(.vars = all_of(name_var), 
                      ~ ifelse(. > 0, 1, 0)) %>% 
  summarise_at(.vars =  all_of(name_var),
   ~survey_mean(.)), .id = "anio")
```

## Bolivia 2015 a 2020
\tiny
```{r, eval=TRUE}
future_map_dfr(diseno, function(dis){
  future_map_dfc(name_var, function(var_id){
    dis %>% filter_at(all_of(var_id), ~ . > 0) %>% 
    summarise_at(all_of(var_id), ~survey_mean(.))
  })
}, .id = "anio")

```

## ¡Gracias!

::: yellow
*Email*: [andres.gutierrez\@cepal.org](mailto:andres.gutierrez@cepal.org){.email}
:::




